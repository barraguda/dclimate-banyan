use crate::types::Value;

// --- Banyan Query Logic ---
use super::types::{ColumnarTreeTypes, RichRangeKey};
use banyan::index::CompactSeq;
use banyan::index::{BranchIndex, LeafIndex};
use banyan::query::Query;
use std::{collections::BTreeMap, fmt::Debug, ops::Bound};
use tracing::{debug, error, info, trace, warn};

/// Banyan Query struct - only contains offset and time ranges for Banyan tree traversal
#[derive(Debug, Clone)]
pub struct ColumnarBanyanQuery {
    /// TODO: Docs
    pub offset_range: (Bound<u64>, Bound<u64>),
    /// TODO: Docs
    pub time_range_micros: (Bound<i64>, Bound<i64>),
}

// Helper function to check if two potentially unbounded ranges intersect.
// Ranges are inclusive start, exclusive end for comparison logic.
fn ranges_intersect<T: PartialOrd>(
    r1_start: Bound<T>,
    r1_end: Bound<T>,
    r2_start: Bound<T>,
    r2_end: Bound<T>,
) -> bool {
    // Check if r1 is entirely before r2
    let r1_before_r2 = match (r1_end, r2_start) {
        (Bound::Included(e1), Bound::Included(s2)) => e1 < s2,
        (Bound::Excluded(e1), Bound::Included(s2)) => e1 <= s2, // if end is excluded, need <=
        (Bound::Included(e1), Bound::Excluded(s2)) => e1 <= s2, // if start is excluded, need <=
        (Bound::Excluded(e1), Bound::Excluded(s2)) => e1 <= s2,
        (_, Bound::Unbounded) => false, // r1 cannot be before unbounded start
        (Bound::Unbounded, _) => false, // unbounded end cannot be before anything
        _ => false,                     // Should handle all cases, but default false
    };

    // Check if r2 is entirely before r1
    let r2_before_r1 = match (r2_end, r1_start) {
        (Bound::Included(e2), Bound::Included(s1)) => e2 < s1,
        (Bound::Excluded(e2), Bound::Included(s1)) => e2 <= s1,
        (Bound::Included(e2), Bound::Excluded(s1)) => e2 <= s1,
        (Bound::Excluded(e2), Bound::Excluded(s1)) => e2 <= s1,
        (_, Bound::Unbounded) => false,
        (Bound::Unbounded, _) => false,
        _ => false,
    };

    // They intersect if neither is entirely before the other
    !r1_before_r2 && !r2_before_r1
}

impl Query<ColumnarTreeTypes> for ColumnarBanyanQuery {
    /// Determine which elements within a leaf *might* be relevant.
    /// This is called *after* intersecting for the branch containing the leaf.
    /// We simplify this: if the leaf's overall key range intersects the query,
    /// mark all elements provided in `res` as potentially relevant. The iterator
    /// will perform exact offset filtering later.
    fn containing(
        &self,
        _leaf_start_offset: u64,
        index: &LeafIndex<ColumnarTreeTypes>,
        res: &mut [bool],
    ) {
        // Check if the KeySeq is empty. This shouldn't happen for a valid leaf
        // node generated by our extend logic, but handle defensively.
        if index.keys.is_empty() {
            warn!("Query::containing called on leaf with empty keys sequence!");
            for r in res.iter_mut() {
                *r = false;
            }
            return;
        }

        // Since keys is not empty, .first() is guaranteed to succeed and return RichRangeKey.
        // No `if let Some` needed here.
        let key: RichRangeKey = index.keys.first(); // Directly get the first key

        let key_offset_start = Bound::Included(key.start_offset);
        let key_offset_end = Bound::Excluded(key.start_offset.saturating_add(key.count));
        let key_time_start = Bound::Included(key.min_timestamp_micros);
        let key_time_end = Bound::Included(key.max_timestamp_micros);

        trace!(
            key = ?key,
            query_offset = ?self.offset_range,
            query_time = ?self.time_range_micros,
            "Query::containing check"
        );

        let offset_intersects = ranges_intersect(
            key_offset_start,
            key_offset_end,
            self.offset_range.0,
            self.offset_range.1,
        );
        let time_intersects = ranges_intersect(
            key_time_start,
            key_time_end,
            self.time_range_micros.0,
            self.time_range_micros.1,
        );

        if offset_intersects && time_intersects {
            trace!(
                "  -> Intersects (Offset: {}, Time: {}). Maintaining res state (len {}).",
                offset_intersects,
                time_intersects,
                res.len()
            );
            // If the key intersects, we don't need to change `res`. Elements marked true
            // by `intersecting` remain true. The iterator handles fine-grained filtering.
        } else {
            trace!(
                "  -> Key does NOT intersect query. Marking res (len {}) as false.",
                res.len()
            );
            // If the key doesn't intersect, prune all elements in this leaf represented by `res`.
            for r in res.iter_mut() {
                *r = false;
            }
        }
    }

    /// Determine which child branches *might* contain relevant data based on their summaries.
    fn intersecting(
        &self,
        _offset: u64, // Base offset of the branch within the stream (unused)
        index: &BranchIndex<ColumnarTreeTypes>,
        res: &mut [bool], // Input/Output: indicates which children are currently considered relevant
    ) {
        for (i, summary) in index.summaries.as_ref().iter().enumerate() {
            // Only check summaries that are currently considered relevant
            if res[i] {
                // Define the summary's ranges (inclusive start, exclusive end for offset)
                let summary_offset_start = Bound::Included(summary.start_offset);
                let summary_offset_end =
                    Bound::Excluded(summary.start_offset.saturating_add(summary.total_count));
                let summary_time_start = Bound::Included(summary.min_timestamp_micros);
                let summary_time_end = Bound::Included(summary.max_timestamp_micros); // Inclusive

                trace!(
                    child_idx = i,
                    summary = ?summary,
                    query_offset = ?self.offset_range,
                    query_time = ?self.time_range_micros,
                    "Query::intersecting check"
                );

                // Check for intersection
                let offset_intersects = ranges_intersect(
                    summary_offset_start,
                    summary_offset_end,
                    self.offset_range.0,
                    self.offset_range.1,
                );
                let time_intersects = ranges_intersect(
                    summary_time_start,
                    summary_time_end,
                    self.time_range_micros.0,
                    self.time_range_micros.1,
                );

                // Update res[i]: if it doesn't intersect, mark as false
                if !(offset_intersects && time_intersects) {
                    res[i] = false;
                    trace!(
                        child_idx = i,
                        summary = ?summary,
                        offset_intersects,
                        time_intersects,
                        "  -> Pruning child"
                    );
                } else {
                    trace!(
                        child_idx = i,
                        summary = ?summary,
                        offset_intersects,
                        time_intersects,
                        "  -> Keeping child"
                    );
                }
            }
        }
    }
}

/// --- Value Filters (Applied *after* Banyan retrieval) ---
#[derive(Debug, Clone, PartialEq)] // Added PartialEq
pub enum Comparison {
    Equals,
    NotEquals,
    GreaterThan,
    GreaterThanOrEqual,
    LessThan,
    LessThanOrEqual,
    // TODO:  In, NotIn, Contains
}

#[derive(Debug, Clone)]
pub struct ValueFilter {
    pub column_name: String,
    pub operator: Comparison,
    pub value: Value, // The value to compare against
}

// Helper to apply filters to a reconstructed row map (String -> Option<Value>)
pub fn apply_value_filters(row: &BTreeMap<String, Option<Value>>, filters: &[ValueFilter]) -> bool {
    if filters.is_empty() {
        return true; // No filters means the row passes
    }
    // All filters must pass
    filters.iter().all(|filter| {
        match row.get(&filter.column_name) {
            Some(Some(row_value)) => {
                trace!(filter = ?filter, value = ?row_value, "Applying filter");
                // Value exists and is not None, perform comparison
                let result = compare_values(row_value, &filter.value, &filter.operator);
                trace!(result = result, " -> Filter result");
                result
            }
            Some(None) => {
                // Value exists but is None (NULL)
                trace!(filter = ?filter, "Applying filter to NULL value");
                // How filters handle NULL is important. Often, comparisons with NULL yield false.
                // Exception: IS NULL / IS NOT NULL filters (if added).
                // Current behavior: NULL comparison fails unless it's `NotEquals NULL`? Let's make it always false for now.
                // Or maybe Equals with Null? Let's define: comparison ops always false with NULL.
                trace!(" -> Filter result: false (NULL value)");
                false // Filter fails if row value is NULL for standard comparisons
            }
            None => {
                // Column not present in the (potentially partial) row map.
                trace!(filter = ?filter, "Applying filter to missing column");
                // This can happen if the column wasn't requested or during processing.
                // Treat as filter failure.
                error!(
                    "Column '{}' required by filter not found in row data: {:?}",
                    filter.column_name, row
                );
                trace!(" -> Filter result: false (missing column)");
                false
            }
        }
    })
}

// Comparison logic (Handles type matching for basic numeric/timestamp comparisons)
fn compare_values(left: &Value, right: &Value, op: &Comparison) -> bool {
    match op {
        Comparison::Equals => left == right, // Relies on Value::PartialEq
        Comparison::NotEquals => left != right, // Relies on Value::PartialEq
        Comparison::GreaterThan => match (left, right) {
            (Value::Integer(l), Value::Integer(r)) => l > r,
            (Value::Float(l), Value::Float(r)) => l > r,
            (Value::Timestamp(l), Value::Timestamp(r)) => l > r,
            // Attempt float/int comparison by promoting int to float
            (Value::Float(l), Value::Integer(r)) => *l > (*r as f64),
            (Value::Integer(l), Value::Float(r)) => (*l as f64) > *r,
            // Other type combinations are not comparable for GT
            _ => false,
        },
        Comparison::GreaterThanOrEqual => match (left, right) {
            (Value::Integer(l), Value::Integer(r)) => l >= r,
            (Value::Float(l), Value::Float(r)) => l >= r,
            (Value::Timestamp(l), Value::Timestamp(r)) => l >= r,
            (Value::Float(l), Value::Integer(r)) => *l >= (*r as f64),
            (Value::Integer(l), Value::Float(r)) => (*l as f64) >= *r,
            _ => false,
        },
        Comparison::LessThan => match (left, right) {
            (Value::Integer(l), Value::Integer(r)) => l < r,
            (Value::Float(l), Value::Float(r)) => l < r,
            (Value::Timestamp(l), Value::Timestamp(r)) => l < r,
            (Value::Float(l), Value::Integer(r)) => *l < (*r as f64),
            (Value::Integer(l), Value::Float(r)) => (*l as f64) < *r,
            _ => false,
        },
        Comparison::LessThanOrEqual => match (left, right) {
            (Value::Integer(l), Value::Integer(r)) => l <= r,
            (Value::Float(l), Value::Float(r)) => l <= r,
            (Value::Timestamp(l), Value::Timestamp(r)) => l <= r,
            (Value::Float(l), Value::Integer(r)) => *l <= (*r as f64),
            (Value::Integer(l), Value::Float(r)) => (*l as f64) <= *r,
            _ => false,
        },
    }
}
